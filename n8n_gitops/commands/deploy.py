"""Deploy command implementation."""

import argparse
import json
from pathlib import Path
from typing import Any

from datetime import datetime

from n8n_gitops.config import load_auth
from n8n_gitops.exceptions import ManifestError, RenderError
from n8n_gitops.gitref import create_snapshot
from n8n_gitops.manifest import load_manifest
from n8n_gitops.n8n_client import N8nClient
from n8n_gitops.normalize import normalize_json
from n8n_gitops.render import RenderOptions, render_workflow_json


def _prepare_workflow_for_api(workflow: dict[str, Any]) -> dict[str, Any]:
    """Prepare workflow for n8n API by removing fields that cause validation errors.

    Args:
        workflow: Workflow object

    Returns:
        Cleaned workflow ready for API submission
    """
    import copy
    cleaned = copy.deepcopy(workflow)

    # Remove fields that n8n API doesn't accept or are auto-generated
    # These are readonly fields managed by n8n
    fields_to_remove = [
        "id",           # Auto-generated by n8n
        "createdAt",    # Auto-generated timestamp
        "updatedAt",    # Auto-generated timestamp
        "versionId",    # Version control field
        "shared",       # Sharing/permissions data
        "isArchived",   # Archive status (managed separately)
        "active",       # Active state (set via separate PATCH request)
        "tags",         # Tags (read-only in PUT, managed separately)
        "meta",         # Metadata (if null, causes issues)
        "pinData",      # Pinned test data (if empty, causes issues)
        "staticData",   # Static data (if null, causes issues)
        "triggerCount", # Trigger counter
    ]

    for field in fields_to_remove:
        cleaned.pop(field, None)

    # Also remove null/empty fields that can cause issues
    # pinData, meta, staticData if they're null or empty
    if cleaned.get("meta") is None:
        cleaned.pop("meta", None)
    if cleaned.get("pinData") == {}:
        cleaned.pop("pinData", None)
    if cleaned.get("staticData") is None:
        cleaned.pop("staticData", None)

    return cleaned


def run_deploy(args: argparse.Namespace) -> None:
    """Deploy workflows to n8n instance.

    Args:
        args: CLI arguments

    Raises:
        SystemExit: If deployment fails
    """
    repo_root = Path(args.repo_root).resolve()
    n8n_root = "n8n"

    # Load auth config
    try:
        auth = load_auth(repo_root, args)
    except Exception as e:
        print(f"Error: {e}")
        raise SystemExit(1)

    # Create snapshot
    snapshot = create_snapshot(repo_root, args.git_ref)

    print(f"Deploying workflows from {repo_root}")
    if args.git_ref:
        print(f"Using git ref: {args.git_ref}")
    print(f"Target: {auth.api_url}")
    print()

    # Load manifest
    try:
        manifest = load_manifest(snapshot, n8n_root)
        print(f"Loaded manifest: {len(manifest.workflows)} workflow(s)")
    except ManifestError as e:
        print(f"Error loading manifest: {e}")
        raise SystemExit(1)

    # Initialize client
    client = N8nClient(auth.api_url, auth.api_key)

    # Fetch remote workflows
    print("\nFetching remote workflows...")
    try:
        remote_workflows = client.list_workflows()
        print(f"Found {len(remote_workflows)} remote workflow(s)")
    except Exception as e:
        print(f"Error fetching remote workflows: {e}")
        raise SystemExit(1)

    # Create name -> id mapping
    name_to_id: dict[str, str] = {}
    for wf in remote_workflows:
        name = wf.get("name")
        wf_id = wf.get("id")
        if name and wf_id:
            name_to_id[name] = wf_id

    # Plan deployment
    plan: list[dict[str, Any]] = []

    for spec in manifest.workflows:
        workflow_path = f"{n8n_root}/{spec.file}"

        # Load workflow
        try:
            workflow_json = snapshot.read_text(workflow_path)
            workflow = json.loads(workflow_json)
        except Exception as e:
            print(f"Error loading workflow {spec.name}: {e}")
            raise SystemExit(1)

        # Render with includes
        render_options = RenderOptions(
            enforce_no_inline_code=False,
            enforce_checksum=False,
            require_checksum=False,
            add_generated_header=False,
        )

        try:
            rendered, reports = render_workflow_json(
                workflow,
                snapshot,
                n8n_root=n8n_root,
                git_ref=args.git_ref,
                options=render_options,
            )
        except RenderError as e:
            print(f"Error rendering workflow {spec.name}: {e}")
            raise SystemExit(1)

        # Ensure name matches manifest
        rendered["name"] = spec.name

        # Determine action (default is replace: delete old + create new)
        if spec.name in name_to_id:
            action = "replace"  # Delete old workflow and create new one
            workflow_id = name_to_id[spec.name]
        else:
            action = "create"
            workflow_id = None

        plan.append(
            {
                "spec": spec,
                "workflow": rendered,
                "action": action,
                "workflow_id": workflow_id,
                "reports": reports,
            }
        )

    # Handle --prune: find workflows to delete
    workflows_to_prune = []
    if args.prune:
        manifest_names = {spec.name for spec in manifest.workflows}
        for wf in remote_workflows:
            wf_name = wf.get("name")
            if wf_name and wf_name not in manifest_names:
                workflows_to_prune.append(wf)

    # Print plan
    print("\nDeployment plan:")
    for item in plan:
        spec = item["spec"]
        action = item["action"]
        if action == "create":
            print(f"  + CREATE: {spec.name}")
        elif action == "replace":
            if args.backup:
                print(f"  âŸ³ REPLACE (with backup): {spec.name}")
            else:
                print(f"  âŸ³ REPLACE: {spec.name}")

        for report in item["reports"]:
            if report.status == "included":
                print(f"      âœ“ Include: {report.include_path}")

    if workflows_to_prune:
        print(f"\n  ðŸ—‘  PRUNE: {len(workflows_to_prune)} workflow(s) not in manifest:")
        for wf in workflows_to_prune:
            print(f"      - {wf.get('name')}")

    # Dry run check
    if args.dry_run:
        print("\n[DRY RUN] No changes made")
        raise SystemExit(0)

    # Execute deployment
    print("\nExecuting deployment...")
    for item in plan:
        spec = item["spec"]
        workflow = item["workflow"]
        action = item["action"]
        workflow_id = item["workflow_id"]

        try:
            # Prepare workflow for API (remove fields that cause validation errors)
            api_workflow = _prepare_workflow_for_api(workflow)

            if action == "create":
                print(f"  Creating: {spec.name}...")
                result = client.create_workflow(api_workflow)
                workflow_id = result.get("id")
                print(f"    âœ“ Created with ID: {workflow_id}")

            elif action == "replace":
                # Replace mode: delete old workflow and create new one
                print(f"  Replacing: {spec.name}...")

                # Backup old workflow if requested
                if args.backup:
                    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    backup_name = f"[BKP {timestamp}] {spec.name}"
                    print(f"    Backing up old workflow as: {backup_name}")

                    # Rename old workflow
                    old_workflow = client.get_workflow(workflow_id)
                    old_workflow["name"] = backup_name
                    old_workflow_cleaned = _prepare_workflow_for_api(old_workflow)
                    client.update_workflow(workflow_id, old_workflow_cleaned)
                    print(f"    âœ“ Backup created")

                    # Now create new workflow with original name
                    print(f"    Creating new workflow...")
                    result = client.create_workflow(api_workflow)
                    workflow_id = result.get("id")
                    print(f"    âœ“ Created with ID: {workflow_id}")
                else:
                    # Delete old workflow and create new one
                    print(f"    Deleting old workflow...")
                    try:
                        client.delete_workflow(workflow_id)
                        print(f"    âœ“ Old workflow deleted")
                    except Exception as e:
                        print(f"    âš  Could not delete old workflow: {e}")
                        print(f"    â†’ Creating new workflow anyway...")

                    print(f"    Creating new workflow...")
                    result = client.create_workflow(api_workflow)
                    workflow_id = result.get("id")
                    print(f"    âœ“ Created with ID: {workflow_id}")

            # Set active state based on manifest
            if workflow_id:
                if spec.active:
                    print(f"    Activating workflow...")
                    client.activate_workflow(workflow_id)
                    print(f"    âœ“ Activated")
                else:
                    print(f"    Deactivating workflow...")
                    client.deactivate_workflow(workflow_id)
                    print(f"    âœ“ Deactivated")

        except Exception as e:
            print(f"    âœ— Error: {e}")

            # Provide helpful suggestions for common errors
            error_str = str(e).lower()
            if "additional properties" in error_str or "validation" in error_str:
                print(f"\n    ðŸ’¡ Tip: The workflow file may contain n8n-managed fields.")
                print(f"    Run 'n8n-gitops validate' to check for problematic fields.")
                print(f"    Re-export the workflow to get a clean version:")
                print(f"      n8n-gitops export --names \"{spec.name}\" --externalize-code")

            raise SystemExit(1)

    # Execute prune if requested
    if workflows_to_prune:
        print(f"\nPruning workflows not in manifest...")
        for wf in workflows_to_prune:
            wf_id = wf.get("id")
            wf_name = wf.get("name")
            try:
                print(f"  Deleting: {wf_name}...")
                client.delete_workflow(wf_id)
                print(f"    âœ“ Deleted")
            except Exception as e:
                print(f"    âœ— Error deleting {wf_name}: {e}")

    print("\nâœ“ Deployment successful!")
